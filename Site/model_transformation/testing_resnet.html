<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ONNX Runtime Web Demo</title>
    <!-- Load ONNX Runtime Web from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
    <button id="loadModelButton">Load Model</button>
    <button id="predictButton" disabled>Predict</button>
    <p id="output"></p>

    <script>
        async function imageUrlToTensor(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "anonymous"; // Needed for loading from external URLs
                // the image loading will be async so, this function that basically returns the tensor,
                // will be used when the img is loaded
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = 224;
                    canvas.height = 224;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, 224, 224);
                    const imageData = ctx.getImageData(0, 0, 224, 224).data;

                    const tensor = new Float32Array(1 * 3 * 224 * 224);
                    // Mannually normalizyng for transforms_3 (the one that transformed for the training of resnet)
                    //transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
                    const mean = [0.485, 0.456, 0.406];
                    const std = [0.229, 0.224, 0.225];

                    for (let y = 0; y < 224; y++) {
                        for (let x = 0; x < 224; x++) {
                            const idx = (y * 224 + x) * 4;
                            const r = imageData[idx] / 255.0;
                            const g = imageData[idx + 1] / 255.0;
                            const b = imageData[idx + 2] / 255.0;
                            tensor[0 * 224 * 224 + y * 224 + x] = (r - mean[0]) / std[0];
                            tensor[1 * 224 * 224 + y * 224 + x] = (g - mean[1]) / std[1];
                            tensor[2 * 224 * 224 + y * 224 + x] = (b - mean[2]) / std[2];
                        }
                    }
                    resolve(tensor);
                };
                //preparing for errors
                img.onerror = reject;
                //starts loading the image
                img.src = url;
            });
        }

        function softmax(arr) {
            const max = Math.max(...arr);
            const exps = arr.map(x => Math.exp(x - max));
            const sum = exps.reduce((a, b) => a + b, 0);
            return exps.map(x => x / sum);
        }
        let session;

        document.getElementById('loadModelButton').onclick = async function() {
            try {
                // Load a model (example: SqueezeNet from ONNX Model Zoo)
                session = await ort.InferenceSession.create(
                    'gleason_predicter.onnx'
                );
                console.log("inputs do modelo: "+ session.inputNames)
                console.log("outputs do modelo: "+ session.outputNames)
                document.getElementById('predictButton').disabled = false;
                document.getElementById('output').innerText = 'Model loaded!';
            } catch (e) {
                document.getElementById('output').innerText = 'Error loading model: ' + e.message;
            }
        };

        document.getElementById('predictButton').onclick = async function() {
            try{
                tensorData=await imageUrlToTensor('g5.jpg');
                const inputTensor = new ort.Tensor('float32', tensorData, [1, 3, 224, 224]);
                
                // Run inference (input name depends on the model, often 'data' or 'input')
                const output = await session.run({ [session.inputNames[0]]: inputTensor });
                const predictions = output[session.outputNames[0]].data;

                chances_array = softmax(Array.from(predictions));
                chances_array = chances_array.map(x => Math.round(x * 100))
                document.getElementById('output').innerText = 
                    'Predictions: \n' + 
                    'G3: '+chances_array[0]+'%\n'+
                    'G4: '+chances_array[1]+'%\n'+
                    'G5: '+chances_array[2]+'%\n'+
                    'NC: '+chances_array[3]+'%\n';
            }catch (e){
                console.error("error "+e.message)
                console.error("Error name:", e.name);
                console.error("Error type:", e.constructor.name);
            }
            
        };
    </script>
</body>
</html>